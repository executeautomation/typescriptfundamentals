// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/events.d.ts
declare module '~selenium-webdriver/lib/events' {
/**
 * Describes an event listener registered on an {@linkplain EventEmitter}.
 */
export class Listener {

    /**
     * @param {!Function} fn The acutal listener function.
     * @param {(Object|undefined)} scope The object in whose scope to invoke the
     *         listener.
     * @param {boolean} oneshot Whether this listener should only be used once.
     */
    constructor(fn: Function, scope: Object, oneshot: boolean);
}

/**
 * Object that can emit events for others to listen for.
 */
export interface EventEmitter {

    /**
     * Registers a listener.
     * 
     * @param {string} type The type of event to listen for.
     * @param {!Function} fn The function to invoke when the event is fired.
     * @param {Object=} opt_self The object in whose scope to invoke the listener.
     * @return {!EventEmitter} A self reference.
     */
    addListener(type: string, fn: Function, opt_self?: Object): EventEmitter;

    /**
     * Fires an event and calls all listeners.
     * @param {string} type The type of event to emit.
     * @param {...*} var_args Any arguments to pass to each listener.
     */
    emit(type: string, ...args: any[]): void;

    /**
     * Returns a mutable list of listeners for a specific type of event.
     * @param {string} type The type of event to retrieve the listeners for.
     * @return {!Listener[]} The registered listeners for the given event
     *     type.
     */
    listeners(type: string): Listener[];

    /**
     * An alias for {@link #addListener() addListener()}.
     * @param {string} type The type of event to listen for.
     * @param {!Function} fn The function to invoke when the event is fired.
     * @param {Object=} opt_self The object in whose scope to invoke the listener.
     * @return {!EventEmitter} A self reference.
     */
    on(type: string, fn: Function, opt_self?: Object): EventEmitter;

    /**
     * Registers a one-time listener which will be called only the first time an
     * event is emitted, after which it will be removed.
     * @param {string} type The type of event to listen for.
     * @param {!Function} fn The function to invoke when the event is fired.
     * @param {Object=} opt_self The object in whose scope to invoke the listener.
     * @return {!EventEmitter} A self reference.
     */
    once(type: string, fn: Function, opt_self?: Object): EventEmitter;

    /**
     * Removes a previously registered event listener.
     * @param {string} type The type of event to unregister.
     * @param {!Function} listenerFn The handler function to remove.
     * @return {!EventEmitter} A self reference.
     */
    removeListener(type: string, listenerFn: Function): EventEmitter;

    /**
     * Removes all listeners for a specific type of event. If no event is
     * specified, all listeners across all types will be removed.
     * @param {string=} opt_type The type of event to remove listeners from.
     * @return {!EventEmitter} A self reference.
     */
    removeAllListeners(opt_type: any): EventEmitter;
}
}
declare module 'selenium-webdriver/lib/events' {
export * from '~selenium-webdriver/lib/events';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/command.d.ts
declare module '~selenium-webdriver/lib/command' {
import {Promise} from '~selenium-webdriver/lib/promise';

/**
 * Describes a command to execute.
 */
export interface Command {

    /** 
     * @param {string} name The name of this command. 
     */
    new (name: string): Command;

    /** 
     * @return {string} This command's name. 
     */
    getName(): string;

    /**
     * Sets a parameter to send with this command.
     * @param {string} name The parameter name.
     * @param {Object} value The parameter value.
     * @return {Command} A self reference.
     */
    setParameter(name: string, value: Object): Command;

    /**
     * Sets the parameters for this command.
     * @param {Object<*>} parameters The command parameters.
     * @return {Command} A self reference.
     */
    setParameters(parameters: Object): Command;

    /**
     * Returns a named command parameter.
     * @param {string} key The parameter key to look up.
     * @return {Object} The parameter value, or undefined if it has not been set.
     */
    getParameter(key: string): Object;

    /**
     * @return {Object} The parameters to send with this command.
     */
    getParameters(): Object;
}

export enum Name {
    GET_SERVER_STATUS,

    NEW_SESSION,
    GET_SESSIONS,
    DESCRIBE_SESSION,

    CLOSE,
    QUIT,

    GET_CURRENT_URL,
    GET,
    GO_BACK,
    GO_FORWARD,
    REFRESH,

    ADD_COOKIE,
    GET_COOKIE,
    GET_ALL_COOKIES,
    DELETE_COOKIE,
    DELETE_ALL_COOKIES,

    GET_ACTIVE_ELEMENT,
    FIND_ELEMENT,
    FIND_ELEMENTS,
    FIND_CHILD_ELEMENT,
    FIND_CHILD_ELEMENTS,

    CLEAR_ELEMENT,
    CLICK_ELEMENT,
    SEND_KEYS_TO_ELEMENT,
    SUBMIT_ELEMENT,

    GET_CURRENT_WINDOW_HANDLE,
    GET_WINDOW_HANDLES,
    GET_WINDOW_POSITION,
    SET_WINDOW_POSITION,
    GET_WINDOW_SIZE,
    SET_WINDOW_SIZE,
    MAXIMIZE_WINDOW,

    SWITCH_TO_WINDOW,
    SWITCH_TO_FRAME,
    GET_PAGE_SOURCE,
    GET_TITLE,

    EXECUTE_SCRIPT,
    EXECUTE_ASYNC_SCRIPT,

    GET_ELEMENT_TEXT,
    GET_ELEMENT_TAG_NAME,
    IS_ELEMENT_SELECTED,
    IS_ELEMENT_ENABLED,
    IS_ELEMENT_DISPLAYED,
    GET_ELEMENT_LOCATION,
    GET_ELEMENT_LOCATION_IN_VIEW,
    GET_ELEMENT_SIZE,
    GET_ELEMENT_ATTRIBUTE,
    GET_ELEMENT_VALUE_OF_CSS_PROPERTY,
    ELEMENT_EQUALS,

    SCREENSHOT,
    TAKE_ELEMENT_SCREENSHOT,
    IMPLICITLY_WAIT,
    SET_SCRIPT_TIMEOUT,
    SET_TIMEOUT,

    ACCEPT_ALERT,
    DISMISS_ALERT,
    GET_ALERT_TEXT,
    SET_ALERT_TEXT,
    SET_ALERT_CREDENTIALS,

    EXECUTE_SQL,
    GET_LOCATION,
    SET_LOCATION,
    GET_APP_CACHE,
    GET_APP_CACHE_STATUS,
    CLEAR_APP_CACHE,
    IS_BROWSER_ONLINE,
    SET_BROWSER_ONLINE,

    GET_LOCAL_STORAGE_ITEM,
    GET_LOCAL_STORAGE_KEYS,
    SET_LOCAL_STORAGE_ITEM,
    REMOVE_LOCAL_STORAGE_ITEM,
    CLEAR_LOCAL_STORAGE,
    GET_LOCAL_STORAGE_SIZE,

    GET_SESSION_STORAGE_ITEM,
    GET_SESSION_STORAGE_KEYS,
    SET_SESSION_STORAGE_ITEM,
    REMOVE_SESSION_STORAGE_ITEM,
    CLEAR_SESSION_STORAGE,
    GET_SESSION_STORAGE_SIZE,

    SET_SCREEN_ORIENTATION,
    GET_SCREEN_ORIENTATION,

    // These belong to the Advanced user interactions - an element is
    // optional for these commands.
    CLICK,
    DOUBLE_CLICK,
    MOUSE_DOWN,
    MOUSE_UP,
    MOVE_TO,
    SEND_KEYS_TO_ACTIVE_ELEMENT,

    // These belong to the Advanced Touch API
    TOUCH_SINGLE_TAP,
    TOUCH_DOWN,
    TOUCH_UP,
    TOUCH_MOVE,
    TOUCH_SCROLL,
    TOUCH_DOUBLE_TAP,
    TOUCH_LONG_PRESS,
    TOUCH_FLICK,

    GET_AVAILABLE_LOG_TYPES,
    GET_LOG,
    GET_SESSION_LOGS,

    // Non-standard commands used by the standalone Selenium server.
    UPLOAD_FILE
}

export interface Executor {
    execute(command: Command): Promise<any>;
}
}
declare module 'selenium-webdriver/lib/command' {
export * from '~selenium-webdriver/lib/command';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/webdriver.d.ts
declare module '~selenium-webdriver/lib/webdriver' {
import {Session} from '~selenium-webdriver/lib/session';
import {Promise, ControlFlow, Thenable} from '~selenium-webdriver/lib/promise';
import {Executor, Command} from '~selenium-webdriver/lib/command';
import {ActionSequence, TouchSequence} from '~selenium-webdriver/lib/actions';
import {Type, Entry} from '~selenium-webdriver/lib/logging';
import {By} from '~selenium-webdriver/lib/by';
import {Capabilities} from '~selenium-webdriver/lib/capabilities';
import {FileDetector} from '~selenium-webdriver/lib/input';

export class Alert {
    constructor(driver: WebDriver, text: string);

    accept(): Promise<void>;

    authenticateAs(username: string, password: string): Promise<void>;

    dismiss(): Promise<void>;

    getText(): Promise<void>;

    sendKeys(text: string): Promise<void>;
}

export class AlertPromise extends Alert implements Thenable<Alert> {
    constructor(driver: WebDriver, text: string);

    cancel(opt_reason: string | Error): void;

    catch<R>(errback: Function): Promise<R>;

    finally<R>(callback: Function): Promise<R>;

    isPending(): boolean;

    then<R>(opt_callback: Function, opt_errback: Function): Promise<R>;
}

export class WebDriver {
    constructor(sessio: Session | Promise<any>, executor: Executor, opt_flow?: ControlFlow);

    actions(): ActionSequence;

    call<T>(fn: Function | Promise<T>, opt_scope: Object, ...var_args: Object[]): Promise<T>;

    close<T>(): Promise<T>;

    controlFlow(): ControlFlow;

    executeAsyncScript<T>(script: string | Function, ...var_args: Object[]): Promise<T>;

    executeScript<T>(script: string | Function, ...var_args: Object[]): Promise<T>;

    findElement(locator: By | Function): WebElementPromise;

    findElements(locator: By | Function): Promise<WebElement[]>;

    get(url: string): Promise<void>

    getAllWindowHandles(): Promise<string[]>;

    getCapabilities(): Promise<Capabilities>;

    getCurrentUrl(): Promise<string>;

    getExecutor(): Executor;

    getPageSource(): Promise<string>;

    getSession(): Promise<Session>;

    getTitle(): Promise<string>;

    getWindowHandle(): Promise<string>;

    manage(): Options;

    navigate(): Navigation;

    quit(): Promise<void>;

    schedule<T>(command: Command, description: string): Promise<T>;

    setFileDetector(detector: FileDetector): void;

    sleep(ms: number): Promise<void>;

    switchTo(): TargetLocator;

    takeScreenshot(): Promise<string>;

    touchActions(): TouchSequence;

    wait<T>(condition: Promise<T> | Condition<T> | Function, opt_timeout: number, opt_message?: string): Promise<T> | WebElementPromise;

    static attachToSession(executor: Executor, sessionId: string, opt_flow: ControlFlow): WebDriver;

    static createSession(executor: Executor, capabilities: Capabilities, opt_flow: ControlFlow): WebDriver;
}

export class Condition<OUT> {
    constructor(message: string, fn: Function);

    description(): string;

    fn(arg0: WebDriver): OUT;
}

export class Logs {
    constructor(driver: WebDriver);

    get(type: Type): Promise<Entry[]>;

    getAvailableLogTypes(): Promise<Type[]>;
}

export class Navigation {
    constructor(driver: WebDriver);

    back(): Promise<void>;

    forward(): Promise<void>;

    refresh(): Promise<void>;

    to(url: string): Promise<void>;
}

export class Options {
    constructor(driver: WebDriver);

    addCookie(spec: Object): Promise<void>;

    deleteAllCookies(): Promise<void>;

    deleteCookie(name: string): Promise<void>;

    getCookie(name: string): Promise<Object>;

    getCookies(): Promise<Object[]>;

    logs(): Logs;

    timeouts(): Timeouts;

    window(): Window;
}

export class Timeouts {
    constructor(driver: WebDriver);

    implicitlyWait(ms: number): Promise<void>;

    pageLoadTimeout(ms: number): Promise<void>;

    setScriptTimeout(ms: number): Promise<void>;
}

export class Window {
    constructor(driver: WebDriver);

    getPosition(): Promise<Object>;

    getSize(): Promise<Object>;

    maximize(): Promise<void>;

    setPosition(x: number, y: number): Promise<void>;

    setSize(width: number, height: number): Promise<void>;
}

export class WebElement {
    constructor(driver: WebDriver, id: Thenable<string> | string);

    clear(): Promise<void>;

    click(): Promise<void>;

    findElement(locator: By | Function): WebElementPromise;

    findElements(locator: By | Function): Promise<WebElement>;

    getAttribute(attributeName: string): Promise<string>;

    getCssValue(cssStyleProperty: string): Promise<string>;

    getDriver(): WebDriver;

    getId(): Promise<string>;

    getLocation(): Promise<Object>;

    getSize(): Promise<Object>;

    getTagName(): Promise<string>;

    getText(): Promise<string>;

    isDisplayed(): Promise<boolean>;

    isEnabled(): Promise<boolean>;

    isSelected(): Promise<boolean>;

    sendKeys(...var_args: Object[]): number | string | Thenable<number | string>;

    submit(): Promise<void>;

    takeScreenshot(opt_scroll: boolean): Promise<string>;

    static buildId(id: string, opt_noLegacy: boolean): Object;

    static equals(a: WebElement, b: WebElement): Promise<boolean>;

    static extractId(obj: any): string;

    static isId(obj: any): boolean;
}

export class WebElementPromise extends WebElement implements Thenable<WebElement> {
    constructor(driver: WebDriver, el: Promise<WebElement>);

    cancel(opt_reason: string | Error): void;

    catch<R>(errback: Function): Promise<R>;

    finally<R>(callback: Function): Promise<R>;

    isPending(): boolean;

    then<R>(opt_callback: Function, opt_errback: Function): Promise<R>;

    static buildId(id: string, opt_noLegacy: boolean): Object;

    static equals(a: WebElement, b: WebElement): Promise<boolean>;

    static extractId(obj: any): string;

    static isId(obj: any): boolean;
}

export class WebElementCondition extends Condition<WebElement | WebElementPromise> {
    constructor(message: string, fn: Function | WebElement | WebElementPromise);
}

export class TargetLocator {
    constructor(driver: WebDriver);

    activeElement(): WebElementPromise;

    alert(): AlertPromise;

    defaultContent(): Promise<void>;

    frame(id?: number | WebElement): Promise<void>;

    window(nameOrHandle: string): Promise<void>
}
}
declare module 'selenium-webdriver/lib/webdriver' {
export * from '~selenium-webdriver/lib/webdriver';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/input.d.ts
declare module '~selenium-webdriver/lib/input' {
import {WebDriver} from '~selenium-webdriver/lib/webdriver';
import {Promise} from '~selenium-webdriver/lib/promise';

export enum Button {
    LEFT,
    MIDDLE,
    RIGHT
}

export type Key = {
    NULL: '\uE000',
    CANCEL: '\uE001',  // ^break
    HELP: '\uE002',
    BACK_SPACE: '\uE003',
    TAB: '\uE004',
    CLEAR: '\uE005',
    RETURN: '\uE006',
    ENTER: '\uE007',
    SHIFT: '\uE008',
    CONTROL: '\uE009',
    ALT: '\uE00A',
    PAUSE: '\uE00B',
    ESCAPE: '\uE00C',
    SPACE: '\uE00D',
    PAGE_UP: '\uE00E',
    PAGE_DOWN: '\uE00F',
    END: '\uE010',
    HOME: '\uE011',
    ARROW_LEFT: '\uE012',
    LEFT: '\uE012',
    ARROW_UP: '\uE013',
    UP: '\uE013',
    ARROW_RIGHT: '\uE014',
    RIGHT: '\uE014',
    ARROW_DOWN: '\uE015',
    DOWN: '\uE015',
    INSERT: '\uE016',
    DELETE: '\uE017',
    SEMICOLON: '\uE018',
    EQUALS: '\uE019',

    NUMPAD0: '\uE01A',  // number pad keys
    NUMPAD1: '\uE01B',
    NUMPAD2: '\uE01C',
    NUMPAD3: '\uE01D',
    NUMPAD4: '\uE01E',
    NUMPAD5: '\uE01F',
    NUMPAD6: '\uE020',
    NUMPAD7: '\uE021',
    NUMPAD8: '\uE022',
    NUMPAD9: '\uE023',
    MULTIPLY: '\uE024',
    ADD: '\uE025',
    SEPARATOR: '\uE026',
    SUBTRACT: '\uE027',
    DECIMAL: '\uE028',
    DIVIDE: '\uE029',

    F1: '\uE031',  // function keys
    F2: '\uE032',
    F3: '\uE033',
    F4: '\uE034',
    F5: '\uE035',
    F6: '\uE036',
    F7: '\uE037',
    F8: '\uE038',
    F9: '\uE039',
    F10: '\uE03A',
    F11: '\uE03B',
    F12: '\uE03C',

    COMMAND: '\uE03D',  // Apple command key
    META: '\uE03D'   // alias for Windows key
}

export class FileDetector {
    constructor();

    handleFile(driver: WebDriver, path: string): Promise<string>;
}
}
declare module 'selenium-webdriver/lib/input' {
export * from '~selenium-webdriver/lib/input';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/by.d.ts
declare module '~selenium-webdriver/lib/by' {
export class By {
    using: string;
    value: string;

    constructor(using: string, value: string);

    toString(): string;

    static className(name: string): By;

    static css(selector: string): By;

    static id(id: string): By;

    static js(script: string | Function, ...var_args: any[]): By;

    static linkText(text: string): By;

    static name(name: string): By;

    static partialLinkText(text: string): By;

    static tagName(name: string): By;

    static xpath(xpath: string): By;
}

export function checkedLocator(arg0: By | { className: string } | { id: string } | { js: string } | { linkText: string } | { name: string }
    | { partialLinkText: string } | { tagName: string } | { xpath: string }): By | Function;
}
declare module 'selenium-webdriver/lib/by' {
export * from '~selenium-webdriver/lib/by';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/capabilities.d.ts
declare module '~selenium-webdriver/lib/capabilities' {
import {Preferences} from '~selenium-webdriver/lib/logging';

/**
 * Constants for browser
 */
export enum Browser {
    ANDROID,
    CHROME,
    EDGE,
    FIREFOX,
    IE,
    INTERNET_EXPLORER,
    IPAD,
    IPHONE,
    OPERA,
    PHANTOM_JS,
    SAFARI,
    HTMLUNIT
}

export enum Capability {
    ACCEPT_SSL_CERTS,
    BROWSER_NAME,
    ELEMENT_SCROLL_BEHAVIOR,
    HANDLES_ALERTS,
    LOGGING_PREFS,
    NATIVE_EVENTS,
    PLATFORM,
    PROXY,
    ROTATABLE,
    SECURE_SSL,
    SUPPORTS_APPLICATION_CACHE,
    SUPPORTS_CSS_SELECTORS,
    SUPPORTS_JAVASCRIPT,
    SUPPORTS_LOCATION_CONTEXT,
    TAKES_SCREENSHOT,
    UNEXPECTED_ALERT_BEHAVIOR,
    VERSION
}

export interface ProxyConfig {
    ftpProxy?: string;
    httpProxy?: string;
    noProxy?: string;
    proxyAutoconfigUrl?: string;
    proxyType?: string;
    sslProxy?: string;
}

export class Capabilities extends Map {
    constructor(opt_other?: Object);

    clear(): void;

    merge(other: Capabilities | Map<String, Object> | Object): Capabilities;

    setAlertBehavior(behavior: string): Capabilities;

    setEnableNativeEvents(enabled: boolean): Capabilities;

    setLoggingPrefs(prefs: Preferences): Capabilities;

    setProxy(proxy: ProxyConfig): Capabilities;

    setScrollBehavior(behavior: number): Capabilities;

    static android(): Capabilities;

    static chrome(): Capabilities;

    static edge(): Capabilities;

    static firefox(): Capabilities;

    static htmlunit(): Capabilities;

    static htmlunitwithjs(): Capabilities;

    static ie(): Capabilities;

    static ipad(): Capabilities;

    static iphone(): Capabilities;

    static opera(): Capabilities;

    static phantomjs(): Capabilities;

    static safari(): Capabilities;
}
}
declare module 'selenium-webdriver/lib/capabilities' {
export * from '~selenium-webdriver/lib/capabilities';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/session.d.ts
declare module '~selenium-webdriver/lib/session' {
import {Capabilities} from '~selenium-webdriver/lib/capabilities';

export class Session {
    constructor(id: string, capabilities: Object | Capabilities);

    getCapabilities(): Capabilities;

    getCapability(key: string): Object;

    getId(): string;

    toJSON(arg0: string): string;
}
}
declare module 'selenium-webdriver/lib/session' {
export * from '~selenium-webdriver/lib/session';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/actions.d.ts
declare module '~selenium-webdriver/lib/actions' {
import {WebDriver, WebElement} from '~selenium-webdriver/lib/webdriver';
import {Button, Key} from '~selenium-webdriver/lib/input';
import {Promise} from '~selenium-webdriver/lib/promise';

export class ActionSequence {
    constructor(driver: WebDriver);

    click(opt_elementOrButton?: WebElement | Button, opt_button?: Button): ActionSequence;

    doubleClick(opt_elementOrButton?: WebElement | Button, opt_button?: Button): ActionSequence;

    dragAndDrop(element: WebElement, location: WebElement | { x: number, y: number }): ActionSequence;

    keyDown(key: Key): ActionSequence;

    keyUp(key: Key): ActionSequence;

    mouseDown(opt_elementOrButton?: WebElement | Button, opt_button?: Button): ActionSequence;

    mouseMove(location: WebElement | { x: number, y: number }, opt_offset: { x: number, y: number }): ActionSequence;

    mouseUp(opt_elementOrButton?: WebElement | Button, opt_button?: Button): ActionSequence;

    perform(): Promise<void>;

    sendKeys(...var_args: (string | Key)[]): ActionSequence
}

export class TouchSequence {
    constructor(driver: WebDriver);

    doubleTap(elem: WebElement): TouchSequence;

    flick(speed: { xspeed: number, yspeed: number }): TouchSequence;

    flickElement(elem: WebElement, offset: { x: number, y: number }, speed: number): TouchSequence;

    longPress(elem: WebElement): TouchSequence;

    move(location: { x: number, y: number }): TouchSequence;

    perform(): Promise<void>;

    release(location: { x: number, y: number }): TouchSequence;

    scroll(offset: { x: number, y: number }): TouchSequence;

    scrollFromElement(elem: WebElement, offset: { x: number, y: number }): TouchSequence;

    tap(elem: WebElement): TouchSequence;

    tapAndHold(location: { x: number, y: number }): TouchSequence;
}
}
declare module 'selenium-webdriver/lib/actions' {
export * from '~selenium-webdriver/lib/actions';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/http.d.ts
declare module '~selenium-webdriver/lib/http' {
import {Executor as _Executor, Command} from '~selenium-webdriver/lib/command';
import {Promise, Thenable} from '~selenium-webdriver/lib/promise';

/**
 * Represents a HTTP request message. This class is a "partial" request and only defines the path on the server to send
 *  a request to. It is each client's responsibility to build the full URL for the final request.
 */
export class Request {
    data: Object;
    headers: Map<string, string>;
    method: string;
    path: string;

    constructor(method: string, path: string, opt_data?: Object);
}

/**
 * Represents a HTTP response message.
 */
export class Response {
    body: string;
    headers: Map<string, string>;
    status: number;

    constructor(status: number, headers: Map<string, string>, body: string);
}

/**
 * Handles sending HTTP messages to a remote end.
 */
export interface Client {
    /**
     * Sends a request to the server. The client will automatically follow any redirects returned by the server, fulfilling
     * the returned promise with the final response.
     */
    send(httpRequest: Request): Promise<Response>;
}

/**
 * A command executor that communicates with the server using JSON over HTTP.
 * 
 * By default, each instance of this class will use the legacy wire protocol from [Selenium project][json].
 * The executor will automatically switch to the [W3C wire protocol][w3c] if the remote end returns a 
 * compliant response to a new session command.
 *
 * [json]: https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol
 * [w3c]: https://w3c.github.io/webdriver/webdriver-spec.html
 */
export class Executor implements _Executor {
    w3c: boolean;

    /**
     * The client to use for sending requests to the server, or a promise-like object that will resolve to to the client.
     */
    constructor(client: Client | Thenable<Client>);

    execute(command: Command): Promise<any>;

    /**
     * Defines a new command for use with this executor. When a command is sent, the path will be preprocessed 
     * using the command's parameters; any path segments prefixed with ":" will be replaced by the parameter 
     * of the same name. For example, given "/person/:name" and the parameters "{name: 'Bob'}", the final 
     * command path will be "/person/Bob".
     */
    defineCommand(name: string, method: string, path: string): void;
}

export function buildPath(path: string, parameters: Map<any, any>): string;
}
declare module 'selenium-webdriver/lib/http' {
export * from '~selenium-webdriver/lib/http';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/remote.d.ts
declare module '~selenium-webdriver/remote' {
import {Thenable, Promise} from '~selenium-webdriver/lib/promise';
import {FileDetector as _FileDetector} from '~selenium-webdriver/lib/input';

/**
 * A record object that defines the configuration options for a DriverService instance.
 */
export interface ServiceOptions {
    /**
     * The arguments to pass to the service. If a promise is provided, the service will wait for it to resolve before starting.
     */
    args?: string[] | Thenable<string[]>;

    /**
     * The environment variables that should be visible to the server process. Defaults to inheriting the current process's environment.
     */
    env?: Map<string, string>;

    /**
     * The host name to access the server on. If this option is specified, the {@link #loopback} option will be ignored.
     */
    hostname?: string;

    /**
     * Whether the service should only be accessed on this host's loopback address.
     */
    loopback?: boolean;

    /**
     * The base path on the server for the WebDriver wire protocol (e.g. '/wd/hub'). Defaults to '/'.
     */
    path?: string;

    /**
     * The port to start the server on (must be > 0). If the port is provided as a promise, the service will wait for the promise to resolve before starting.
     */
    port?: number | Thenable<number>;

    /**
     * IO configuration for the spawned server process. For more information, refer to the documentation of child_process.spawn.
     */
    stdio?: string | (string | number)[];
}

export class FileDetector extends _FileDetector { }

/**
 * Manages the life and death of a native executable WebDriver server.
 * 
 * It is expected that the driver server implements the https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol. Furthermore, 
 * the managed server should support multiple concurrent sessions, so that this class may be reused for multiple clients.
 */
export class DriverService {

    constructor(executable: string, options?: ServiceOptions);

    /**
     * A promise that resolves to the server's address.
     */
    address(): Promise<string>;

    /**
     * Returns whether the underlying process is still running. This does not take into account whether the process is in the process of shutting down.
     */
    isRunning(): boolean;

    /**
     * Stops the service if it is not currently running. This function will kill the server immediately. To synchronize with the active control flow, use {@link #stop()}.
     */
    kill(): Promise<void>

    /**
     * Starts the server if it is not already running.
     */
    start(opt_timeoutMs?: number): Promise<string>;

    /**
     * Schedules a task in the current control flow to stop the server if it is currently running.
     */
    stop(): Promise<void>;
}

/**
 * Manages the life and death of the <a href="http://selenium-release.storage.googleapis.com/index.html">
 * standalone Selenium server</a>.
 */
export class SeleniumServer extends DriverService {
    constructor(jar: string, opt_options?: ServiceOptions);
}
}
declare module 'selenium-webdriver/remote' {
export * from '~selenium-webdriver/remote';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/chrome.d.ts
declare module '~selenium-webdriver/chrome' {
import {Preferences} from '~selenium-webdriver/lib/logging';
import {ProxyConfig, Capabilities} from '~selenium-webdriver/lib/capabilities';
import {WebDriver} from '~selenium-webdriver/lib/webdriver';
import {ControlFlow, Promise} from '~selenium-webdriver/lib/promise';
import {Executor} from '~selenium-webdriver/lib/http';
import {DriverService} from '~selenium-webdriver/remote';

export class Options {
    constructor();

    /**
     * Add additional command line arguments to use when launching the Chrome browser. Each argument may be specified with or without
     * the "--" prefix (e.g. "--foo" and "foo"). Arguments with an associated value should be delimited by an "=": "foo=bar".
     */
    addArguments(...var_args: string[]): Options;

    /**
     * Add additional extensions to install when launching Chrome. Each extension should be specified as the path to the packed CRX file, or a Buffer for an extension.
     */
    addExtensions(...var_args: (string | Buffer)[]): Options;

    /**
     * Sets the name of the activity hosting a Chrome-based Android WebView. This option must be set to connect to an
     *  [Android WebView](https://sites.google.com/a/chromium.org/chromedriver/getting-started/getting-started---android)
     */
    androidActivity(name: string): Options;

    /**
     * Configures the ChromeDriver to launch Chrome on Android via adb. This function is shorthand for
     * {@link #androidPackage options.androidPackage('com.android.chrome')}.
     */
    androidChrome(): Options;

    /**
     * Sets the device serial number to connect to via ADB. If not specified, the ChromeDriver will select an unused device at random.
     *  An error will be returned if all devices already have active sessions.
     */
    androidDeviceSerial(serial: string): Options;

    /**
     * Sets the package name of the Chrome or WebView app.
     */
    androidPackage(pkg?: string): Options;

    /**
     * Sets the process name of the Activity hosting the WebView (as given by `ps`). If not specified, the process name is assumed to be the same as
     * {@link #androidPackage}.
     */
    androidProcess(processName: string): Options;

    /**
     * Sets whether to connect to an already-running instead of the specified {@linkplain #androidProcess app} instead of launching the app with a clean
     * data directory.
     */
    androidUseRunningApp(useRunning: boolean): Options;

    /**
     * Sets whether to leave the started Chrome browser running if the controlling ChromeDriver service is killed before {@link webdriver.WebDriver#quit()} is
     * called.
     */
    detachDriver(detach: boolean): Options;

    /**
     * List of Chrome command line switches to exclude that ChromeDriver by default passes when starting Chrome. Do not prefix switches with "--".
     */
    excludeSwitches(...var_args: string[]): Options;

    /**
     * Sets the path to the Chrome binary to use. On Mac OS X, this path should reference the actual Chrome executable, not just the application
     *  binary (e.g. "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome").
     * The binary path be absolute or relative to the chromedriver server executable, but it must exist on the machine that will launch Chrome.
     */
    setChromeBinaryPath(path: string): Options;

    /**
     * Sets the path to Chrome's log file. This path should exist on the machine that will launch Chrome.
     */
    setChromeLogFile(path: string): Options;

    /**
     * Sets the directory to store Chrome minidumps in. This option is only supported when ChromeDriver is running on Linux.
     */
    setChromeMinidumpPath(path: string): Options;

    /**
     * Sets preferences for the "Local State" file in Chrome's user data directory.
     */
    setLocalState(state: Object): Options;

    /**
     * Sets the logging preferences for the new session.
     */
    setLoggingPrefs(prefs: Preferences): Options;

    /**
     * Configures Chrome to emulate a mobile device. For more information, refer
     * to the ChromeDriver project page on [mobile emulation][em]. Configuration
     * options include:
     *
     * - `deviceName`: The name of a pre-configured [emulated device][devem]
     * - `width`: screen width, in pixels
     * - `height`: screen height, in pixels
     * - `pixelRatio`: screen pixel ratio
     */
    setMobileEmulation(config?: { deviceName: string } | { height: number, pixelRatio: number, width: number }): Options;

    /**
     * Sets the performance logging preferences. Options include:
     *
     * - `enableNetwork`: Whether or not to collect events from Network domain.
     * - `enablePage`: Whether or not to collect events from Page domain.
     * - `enableTimeline`: Whether or not to collect events from Timeline domain.
     *     Note: when tracing is enabled, Timeline domain is implicitly disabled,
     *     unless `enableTimeline` is explicitly set to true.
     * - `tracingCategories`: A comma-separated string of Chrome tracing
     *     categories for which trace events should be collected. An unspecified
     *     or empty string disables tracing.
     * - `bufferUsageReportingInterval`: The requested number of milliseconds
     *     between DevTools trace buffer usage events. For example, if 1000, then
     *     once per second, DevTools will report how full the trace buffer is. If
     *     a report indicates the buffer usage is 100%, a warning will be issued.
     */
    setPerfLoggingPrefs(prefs: { bufferUsageReportingInterval: number, enableNetwork: boolean, enablePage: boolean, enableTimeline: boolean, tracingCategories: string }): Options;

    /**
     * Sets the proxy settings for the new session.
     */
    setProxy(proxy: ProxyConfig): Options;

    /**
     * Sets the user preferences for Chrome's user profile. See the "Preferences" file in Chrome's user data directory for examples.
     */
    setUserPreferences(prefs: Object): Options;

    /**
     * Converts this options instance to a {@link Capabilities} object.
     */
    toCapabilities(opt_capabilities?: Capabilities): Options;

    /**
     * Extracts the ChromeDriver specific options from the given capabilities object.
     */
    static fromCapabilities(caps: Capabilities): Options;
}

export class Driver extends WebDriver {
    constructor(opt_config?: Capabilities | Options, opt_service?: DriverService, opt_flow?: ControlFlow, opt_executor?: Executor);

    /**
     * Schedules a command to launch Chrome App with given ID.
     */
    launchApp(id: string): Promise<void>;
}

/**
 * Creates {@link selenium-webdriver/remote.DriverService} instances that manage
 * a [ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver/)
 * server in a child process.
 */
export class ServiceBuilder {
    constructor(opt_exe?: string);

    /**
     * Creates a new DriverService using this instance's current configuration.
     */
    build(): DriverService;

    /**
     * Enables verbose logging.
     */
    enableVerboseLogging(): ServiceBuilder;

    /**
     * Sets the path of the log file the driver should log to. If a log file is not specified, the driver will log to stderr.
     */
    loggingTo(path: string): ServiceBuilder;

    /**
     * Sets which port adb is listening to. _The ChromeDriver will connect to adb if an {@linkplain Options#androidPackage 
     * Android session} is requested, but * adb **must** be started beforehand._
     */
    setAdbPort(port: number): ServiceBuilder;

    /**
     * Sets the number of threads the driver should use to manage HTTP requests. By default, the driver will use 4 threads.
     */
    setNumHttpThreads(n: number): ServiceBuilder;

    setStdio(config: (string | number)[]): ServiceBuilder;

    /**
     * Sets the base path for WebDriver REST commands (e.g. "/wd/hub"). By default, the driver will accept commands relative to "/".
     */
    setUrlBasePath(path: string): ServiceBuilder;

    /**
     * Sets the port to start the ChromeDriver on.
     */
    usingPort(port: number): ServiceBuilder;

    /**
     * Defines the environment to start the server under. This settings will be inherited by every browser session started by the server.
     */
    withEnvironment(env: Map<string, string>): ServiceBuilder;
}

/**
 * Returns the default ChromeDriver service. If such a service has not been configured, one will be constructed using 
 * the default configuration for a ChromeDriver executable found on the system PATH.
 */
export function getDefaultService(): DriverService;

/**
 * Sets the default service to use for new ChromeDriver instances.
 */
export function setDefaultService(service: DriverService): void;
}
declare module 'selenium-webdriver/chrome' {
export * from '~selenium-webdriver/chrome';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/edge.d.ts
declare module '~selenium-webdriver/edge' {
import {ProxyConfig, Capabilities} from '~selenium-webdriver/lib/capabilities';
import {WebDriver} from '~selenium-webdriver/lib/webdriver';
import {ControlFlow} from '~selenium-webdriver/lib/promise';
import {DriverService} from '~selenium-webdriver/remote';

export class Options {
    constructor();

    /**
     * Sets the page load strategy for Edge. Supported values are "normal", "eager", and "none";
     */
    setPageLoadStrategy(pageLoadStrategy: string): Options;

    /**
     * Sets the proxy settings for the new session.
     */
    setProxy(proxy: ProxyConfig): Options;

    /**
     * Converts this options instance to a {@link Capabilities} object.
     */
    toCapabilities(opt_capabilities?: Capabilities): Options;

    /**
     * Extracts the ChromeDriver specific options from the given capabilities object.
     */
    static fromCapabilities(caps: Capabilities): Options;
}

export class Driver extends WebDriver {
    constructor(opt_config?: Capabilities | Options, opt_service?: DriverService, opt_flow?: ControlFlow);
}

/**
 * Creates {@link selenium-webdriver/remote.DriverService} instances that manage
 * a [ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver/)
 * server in a child process.
 */
export class ServiceBuilder {
    constructor(opt_exe: string);

    /**
     * Creates a new DriverService using this instance's current configuration.
     */
    build(): DriverService;

    setStdio(config: (string | number)[]): ServiceBuilder;

    /**
     * Sets the port to start the ChromeDriver on.
     */
    usingPort(port: number): ServiceBuilder;

    /**
     * Defines the environment to start the server under. This settings will be inherited by every browser session started by the server.
     */
    withEnvironment(env: Map<string, string>): ServiceBuilder;
}

/**
 * Returns the default ChromeDriver service. If such a service has not been configured, one will be constructed using 
 * the default configuration for a ChromeDriver executable found on the system PATH.
 */
export function getDefaultService(): DriverService;

/**
 * Sets the default service to use for new ChromeDriver instances.
 */
export function setDefaultService(service: DriverService): void;
}
declare module 'selenium-webdriver/edge' {
export * from '~selenium-webdriver/edge';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/ie.d.ts
declare module '~selenium-webdriver/ie' {
import {ProxyConfig, Capabilities} from '~selenium-webdriver/lib/capabilities';
import {WebDriver} from '~selenium-webdriver/lib/webdriver';
import {ControlFlow} from '~selenium-webdriver/lib/promise';

export class Options {
    constructor();

    /**
     * Specifies command-line switches to use when launching Internet Explorer. This is only valid when used with {@link #forceCreateProcessApi}.
     */
    addArguments(...var_args: (string | number)[]): Options;

    /**
     * Configures the timeout, in milliseconds, that the driver will attempt to located and attach to a newly opened instance of Internet Explorer.
     * The default is zero, which indicates waiting indefinitely.
     */
    browserAttachTimeout(timeout: number): Options;

    /**
     * Configures whether the driver should attempt to remove obsolete {@linkplain webdriver.WebElement WebElements} from its internal cache on
     * page navigation (true by default). Disabling this option will cause the driver to run with a larger memory footprint.
     */
    enableElementCacheCleanup(enable: boolean): Options;

    /**
     * Configures whether to enable persistent mouse hovering (true by default). Persistent hovering is achieved by continuously firing 
     * mouse over events at the last location the mouse cursor has been moved to.
     */
    enablePersistentHover(enable: boolean): Options;

    /**
     * Configures whether to clear the cache, cookies, history, and saved form data before starting the browser. 
     * _Using this capability will clear session data for all running instances of Internet Explorer, including those started manually._
     */
    ensureCleanSession(cleanSession: boolean): Options;

    /**
     * Configures whether to launch Internet Explorer using the CreateProcess API. If this option is not specified, IE is launched using
     *  IELaunchURL, if available. For IE 8 and above, this option requires the TabProcGrowth registry value to be set to 0.
     */
    forceCreateProcessApi(force: boolean): Options;

    /**
     * Indicates whether to skip the check that the browser's zoom level is set to 100%.
     */
    ignoreZoomSetting(ignore: boolean): Options;

    /**
     * Sets the initial URL loaded when IE starts. This is intended to be used with {@link #ignoreProtectedModeSettings} to allow the user to initialize IE in
     * the proper Protected Mode zone. Setting this option may cause browser instability or flaky and unresponsive code. Only "best effort" support is
     * provided when using this option.
     */
    initialBrowserUrl(url: string): Options;

    /**
     * Whether to disable the protected mode settings check when the session is created. Disbling this setting may lead to significant instability as the
     * browser may become unresponsive/hang. Only "best effort" support is provided when using this capability.
     *
     * For more information, refer to the IEDriver's [required system configuration](http://goo.gl/eH0Yi3).
     */
    introduceFlakinessByIgnoringProtectedModeSettings(ignoreSettings: boolean): Options;

    /**
     * Configures whether to require the IE window to have input focus before performing any user interactions (i.e. mouse or keyboard events).
     *  This option is disabled by default, but delivers much more accurate interaction events when enabled.
     */
    requireWindowFocus(require: boolean): Options;

    /**
     * Sets the path of the temporary data directory to use.
     */
    setExtractPath(path: string): Options;

    /**
     * Sets the IP address of the driver's host adapter.
     */
    setHost(host: string): Options;

    /**
     * Sets the path to the log file the driver should log to.
     */
    setLogFile(file: string): Options;

    /**
     * Sets the IEDriverServer's logging level.
     */
    setLogLevel(level: string): Options;

    /**
     * Sets the proxy settings for the new session.
     */
    setProxy(proxy: ProxyConfig): Options;

    /**
     * Sets whether the driver should start in silent mode.
     */
    silent(silent: boolean): Options;

    /**
     * Converts this options instance to a {@link Capabilities} object.
     */
    toCapabilities(opt_capabilities?: Capabilities): Options;

    /**
     * Configures whether proxies should be configured on a per-process basis. If not set, setting a {@linkplain #setProxy proxy} will configure the system
     * proxy. The default behavior is to use the system proxy.
     */
    usePerProcessProxy(enable: boolean): Options;

    /**
     * Extracts the ChromeDriver specific options from the given capabilities object.
     */
    static fromCapabilities(caps: Capabilities): Options;
}

export enum Level {
    DEBUG,
    ERROR,
    FATAL,
    INFO,
    TRACE,
    WARN
}

export class Driver extends WebDriver {
    constructor(opt_config?: Capabilities | Options, opt_flow?: ControlFlow);
}
}
declare module 'selenium-webdriver/ie' {
export * from '~selenium-webdriver/ie';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/opera.d.ts
declare module '~selenium-webdriver/opera' {
import {ProxyConfig, Capabilities} from '~selenium-webdriver/lib/capabilities';
import {WebDriver} from '~selenium-webdriver/lib/webdriver';
import {ControlFlow} from '~selenium-webdriver/lib/promise';
import {DriverService} from '~selenium-webdriver/remote';
import {Preferences} from '~selenium-webdriver/lib/logging';

export class Options {
    constructor();

    /**
     * Add additional command line arguments to use when launching the Opera browser. Each argument may be specified with or without the "--" prefix
     *  (e.g. "--foo" and "foo"). Arguments with an associated value should be delimited by an "=": "foo=bar".
     */
    addArguments(...var_args: string[]): Options;

    /**
     * Add additional extensions to install when launching Opera. Each extension should be specified as the path to the packed CRX file, or a Buffer for an extension.
     */
    addExtensions(var_args: (string | number)[]): Options;

    /**
     * Sets the logging preferences for the new session.
     */
    setLoggingPrefs(prefs: Preferences): Options;

    /**
     * Sets the path to the Opera binary to use. On Mac OS X, this path should reference the actual Opera executable, not just the application binary.
     * The binary path be absolute or relative to the operadriver server executable, but it must exist on the machine that will launch Opera.
     */
    setOperaBinaryPath(path: string): Options;

    /**
     * Sets the proxy settings for the new session.
     */
    setProxy(proxy: ProxyConfig): Options;

    /**
     * Converts this options instance to a {@link Capabilities} object.
     */
    toCapabilities(opt_capabilities?: Capabilities): Options;

    /**
     * Extracts the ChromeDriver specific options from the given capabilities object.
     */
    static fromCapabilities(caps: Capabilities): Options;
}

export class Driver extends WebDriver {
    constructor(opt_config?: Capabilities | Options, opt_service?: DriverService, opt_flow?: ControlFlow);
}

/**
 * Creates {@link selenium-webdriver/remote.DriverService} instances that manage
 * a [ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver/)
 * server in a child process.
 */
export class ServiceBuilder {
    constructor(opt_exe: string);

    /**
     * Creates a new DriverService using this instance's current configuration.
     */
    build(): DriverService;

    /**
     * Enables verbose logging.
     */
    enableVerboseLogging(): ServiceBuilder;

    /**
     * Sets the path of the log file the driver should log to. If a log file is not specified, the driver will log to stderr.
     */
    loggingTo(path: string): ServiceBuilder;

    setStdio(config: (string | number)[]): ServiceBuilder;

    /**
     * Silence sthe drivers output.
     */
    silent(): ServiceBuilder;

    /**
     * Sets the port to start the ChromeDriver on.
     */
    usingPort(port: number): ServiceBuilder;

    /**
     * Defines the environment to start the server under. This settings will be inherited by every browser session started by the server.
     */
    withEnvironment(env: Map<string, string>): ServiceBuilder;
}

/**
 * Returns the default ChromeDriver service. If such a service has not been configured, one will be constructed using 
 * the default configuration for a ChromeDriver executable found on the system PATH.
 */
export function getDefaultService(): DriverService;

/**
 * Sets the default service to use for new ChromeDriver instances.
 */
export function setDefaultService(service: DriverService): void;
}
declare module 'selenium-webdriver/opera' {
export * from '~selenium-webdriver/opera';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/safari.d.ts
declare module '~selenium-webdriver/safari' {
import {Capabilities} from '~selenium-webdriver/lib/capabilities';
import {WebDriver} from '~selenium-webdriver/lib/webdriver';
import {ControlFlow} from '~selenium-webdriver/lib/promise';
import {Preferences} from '~selenium-webdriver/lib/logging';

export class Options {
    constructor();

    /**
     * Sets whether to force Safari to start with a clean session. Enabling this option will cause all global browser data to be deleted.
     */
    setCleanSession(clean: boolean): Options;

    /**
     * Sets the logging preferences for the new session.
     */
    setLoggingPrefs(prefs: Preferences): Options;

    /**
     * Converts this options instance to a {@link Capabilities} object.
     */
    toCapabilities(opt_capabilities?: Capabilities): Options;

    /**
     * Extracts the ChromeDriver specific options from the given capabilities object.
     */
    static fromCapabilities(caps: Capabilities): Options;
}

export class Driver extends WebDriver {
    constructor(opt_config?: Capabilities | Options, opt_flow?: ControlFlow);
}
}
declare module 'selenium-webdriver/safari' {
export * from '~selenium-webdriver/safari';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/firefox.d.ts
declare module '~selenium-webdriver/firefox' {
import {Promise, ControlFlow} from '~selenium-webdriver/lib/promise';
import {Command} from '~selenium-webdriver/lib/command';
import {Preferences} from '~selenium-webdriver/lib/logging';
import {ProxyConfig, Capabilities} from '~selenium-webdriver/lib/capabilities';
import {WebDriver} from '~selenium-webdriver/lib/webdriver';
import {Executor} from '~selenium-webdriver/lib/http';

// extension
export function install(extension: string, dir: string): Promise<string>;

// profile
/**
 * Decodes a base64 encoded profile.
 */
export function decode(data: string): Promise<string>;

/**
 * Parses a user.js file in a Firefox profile directory.
 */
export function loadUserPrefs(f: string): Promise<Object>;

/**
 * Provides a mechanism to configure and launch Firefox in a subprocess for use with WebDriver.
 *
 * If created _without_ a path for the Firefox binary to use, this class will attempt to find Firefox when {@link #launch()} is called. For OSX and
 * Windows, this class will look for Firefox in the current platform's default installation location (e.g. /Applications/Firefox.app on OSX). For all other
 * platforms, the Firefox executable must be available on your system `PATH`.
 */
export class Binary {
    constructor(opt_exe: string);

    /**
     * Add arguments to the command line used to start Firefox.
     */
    addArguments(...var_args: string[]): void;

    /**
     * Launches Firefox and returns a promise that will be fulfilled when the process terminates.
     */
    launch(profile: string): Promise<Command>;

    /**
     * Returns a promise for the Firefox executable used by this instance. The returned promise will be immediately resolved if the user
     *  supplied an executable path when this instance was created. Otherwise, an attempt will be made to find Firefox on the current system.
     */
    locate(): Promise<string>;

    /**
     * Specifies whether to use Firefox Developer Edition instead of the normal stable channel. Setting this option has no effect if this instance
     *  was created with a path to a specific Firefox binary.
     * 
     * This method has no effect on Unix systems where the Firefox application has the same (default) name regardless of version.
     */
    useDevEdition(opt_use: string): void;
}

/**
 * Models a Firefox profile directory for use with the FirefoxDriver. The {@code Profile} directory uses an in-memory model until
 * {@link #writeToDisk} or {@link #encode} is called.
 */
export class Profile {
    constructor(opt_dir: string);

    acceptUntrustedCerts(): boolean;

    /**
     * Registers an extension to be included with this profile.
     */
    addExtension(extension: string): void;

    assumeUntrustedCertIssuer(): void;

    /**
     * Write profile to disk, compress its containing directory, and return it as a Base64 encoded string.
     */
    encode(): Promise<string>;

    getPort(): number;

    /**
     * Returns the currently configured value of a profile preference. This does not include any defaults defined in the profile's 
     * template directory user.js file (if a template were specified on construction).
     */
    getPreference(key: string): string | number | boolean;

    /**
     * Returns whether native events are enabled in this profile.
     */
    nativeEventsEnabled(): boolean;

    /**
     * Sets whether the FirefoxDriver should automatically accept untrusted SSL certificates.
     */
    setAcceptUntrustedCerts(value: string): void;

    /**
     * Sets whether to assume untrusted certificates come from untrusted issuers.
     */
    setAssumeUntrustedCertIssuer(value: boolean): void;

    /**
     * Specifies which host the driver should listen for commands on. If not specified, the driver will default to "localhost". This option should be
     * specified when "localhost" is not mapped to the loopback address (127.0.0.1) in `/etc/hosts`.
     */
    setHost(host: string): void;

    /**
     * Sets whether to use native events with this profile.
     */
    setNativeEventsEnabled(enabled: boolean): void;

    /**
     * Sets the port to use for the WebDriver extension loaded by this profile.
     */
    setPort(port: number): void;

    /**
     * Sets a desired preference for this profile.
     */
    setPreference(key: string, value: string | number | boolean): void;

    /**
     * Writes this profile to disk.
     */
    writeToDisk(opt_excludeWebDriverExt: boolean): Promise<string>;
}

export enum Context {
    CHROME,
    CONTENT
}

/**
 * Configuration options for the FirefoxDriver.
 */
export class Options {
    constructor();

    /**
     * Sets the binary to use. The binary may be specified as the path to a Firefox executable, or as a {@link Binary} object.
     */
    setBinary(binary: string | Binary): Options;

    /**
     * Sets the logging preferences for the new session.s
     */
    setLoggingPreferences(prefs: Preferences): Options;

    /**
     * Sets the profile to use. The profile may be specified as a {@link Profile} object or as the path to an existing Firefox profile to use
     * as a template.
     */
    setProfile(profile: Profile): Options;

    /**
     * Sets the proxy to use.
     */
    setProxy(proxy: ProxyConfig): Options;

    /**
     * Converts these options to a {@link Capabilities} instance.
     */
    toCapabilities(): Capabilities;

    /**
     * Sets whether to use Mozilla's geckodriver to drive the browser. This option is enabled by default and required for Firefox 47+.
     */
    useGeckoDriver(enable: boolean): void;
}

export class Driver extends WebDriver {
    constructor(opt_config?: Capabilities | Options, opt_flow?: ControlFlow, opt_executor?: Executor);

    /**
     * Get the context that is currently in effect.
     */
    getContext(): Promise<Context>;

    /**
     * Changes target context for commands between chrome- and content.
     *
     * Changing the current context has a stateful impact on all subsequent commands. The {@link Context.CONTENT} context has normal web
     * platform document permissions, as if you would evaluate arbitrary JavaScript. The {@link Context.CHROME} context gets elevated
     * permissions that lets you manipulate the browser chrome itself, with full access to the XUL toolkit.
     *
     * Use your powers wisely.
     *
     */
    setContext(ctx: Promise<Context>): void;
}
}
declare module 'selenium-webdriver/firefox' {
export * from '~selenium-webdriver/firefox';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/builder.d.ts
declare module '~selenium-webdriver/builder' {

import {WebDriver} from '~selenium-webdriver/lib/webdriver';
import {Capabilities, ProxyConfig, Browser} from '~selenium-webdriver/lib/capabilities';
import {ControlFlow} from '~selenium-webdriver/lib/promise';
import {Preferences} from '~selenium-webdriver/lib/logging';
import {Options as ChromeOptions} from '~selenium-webdriver/chrome';
import {Options as EdgeOptions} from '~selenium-webdriver/edge';
import {Options as IEOptions} from '~selenium-webdriver/ie';
import {Options as OperaOptions} from '~selenium-webdriver/opera';
import {Options as SafariOptions} from '~selenium-webdriver/safari';
import {Options as FirefoxOptions} from '~selenium-webdriver/firefox';
import {Agent} from 'http';

export class Builder {
    constructor();

    build(): WebDriver;

    buildAsync(): WebDriver;

    disableEnvironmentOverrides(): Builder;

    forBrowser(name: string | Browser, opt_version?: string, opt_platform?: string): Builder;

    getCapabilities(): Capabilities;

    getHttpAgent(): Agent;

    usingHttpAgent(agent: Agent): void;

    getServerUrl(): string;

    getWebDriverProxy(): string;

    setAlertBehavior(behavior: string): Builder;

    setControlFlow(flow: ControlFlow): Builder;

    setEnableNativeEvents(enabled: boolean): Builder;

    setLoggingPrefs(prefs: Preferences | Object): Builder;

    setProxy(config: ProxyConfig): Builder;

    setScrollBehavior(behavior: number): Builder;

    usingServer(url: string): Builder;

    usingWebDriverProxy(proxy: string): Builder;

    withCapabilities(capabilities: Capabilities | Object): Builder;

    getFirefoxOptions(): FirefoxOptions;

    setChromeOptions(options: ChromeOptions): Builder;

    setFirefoxOptions(options: FirefoxOptions): Builder;

    setEdgeOptions(options: EdgeOptions): Builder;

    setIeOptions(options: IEOptions): Builder;

    setOperaOptions(options: OperaOptions): Builder;

    setSafariOptions(options: SafariOptions): Builder;
}
}
declare module 'selenium-webdriver/builder' {
export * from '~selenium-webdriver/builder';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/error.d.ts
declare module '~selenium-webdriver/lib/error' {
/**
 * An attempt was made to select an element that cannot be selected.
 */
export class ElementNotSelectableError extends WebDriverError {
    new(opt_error: string): ElementNotSelectableError;
}

/**
 * An element command could not be completed because the element is not visible on the page.
 */
export class ElementNotVisibleError extends WebDriverError {
    new(opt_error: string): ElementNotVisibleError;
}

/**
 * The arguments passed to a command are either invalid or malformed.
 */
export class InvalidArgumentError extends WebDriverError {
    new(opt_error: string): InvalidArgumentError;
}

/**
 * An illegal attempt was made to set a cookie under a different domain than the current page.
 */
export class InvalidCookieDomainError extends WebDriverError {
    new(opt_error: string): InvalidCookieDomainError;
}

/**
 * The coordinates provided to an interactions operation are invalid.
 */
export class InvalidElementCoordinatesError extends WebDriverError {
    new(opt_error: string): InvalidCookieDomainError;
}

/**
 * An element command could not be completed because the element is in an invalid state, e.g. attempting to click an
 *  element that is no longer attached to the document.
 */
export class InvalidElementStateError extends WebDriverError {
    new(opt_error: string): InvalidElementStateError;
}

/**
 * Argument was an invalid selector.
 */
export class InvalidSelectorError extends WebDriverError {
    new(opt_error: string): InvalidSelectorError;
}

/**
 * An error occurred while executing JavaScript supplied by the user.
 */
export class JavascriptError extends WebDriverError {
    new(opt_error: string): JavascriptError;
}

/**
 * The target for mouse interaction is not in the browsers viewport and cannot be brought into that viewport.
 */
export class MoveTargetOutOfBoundsError extends WebDriverError {
    new(opt_error: string): MoveTargetOutOfBoundsError;
}

/**
 * An attempt was made to operate on a modal dialog when one was not open.
 */
export class NoSuchAlertError extends WebDriverError {
    new(opt_error: string): NoSuchAlertError;
}

/**
 * An element could not be located on the page using the given search parameters.
 */
export class NoSuchElementError extends WebDriverError {
    new(opt_error: string): NoSuchElementError;
}

/**
 * A request to switch to a frame could not be satisfied because the frame could not be found.
 */
export class NoSuchFrameError extends WebDriverError {
    new(opt_error: string): NoSuchFrameError;
}

/**
 * Occurs when a command is directed to a session that does not exist.
 */
export class NoSuchSessionError extends WebDriverError {
    new(opt_error: string): NoSuchSessionError;
}

/**
 * A request to switch to a window could not be satisfied because the window could not be found.
 */
export class NoSuchWindowError extends WebDriverError {
    new(opt_error: string): NoSuchWindowError;
}

/**
 * A script did not complete before its timeout expired.
 */
export class ScriptTimeoutError extends WebDriverError {
    new(opt_error: string): ScriptTimeoutError;
}

/**
 * A new session could not be created.
 */
export class SessionNotCreatedError extends WebDriverError {
    new(opt_error: string): SessionNotCreatedError;
}

/**
 * An element command failed because the referenced element is no longer attached to the DOM.
 */
export class StaleElementReferenceError extends WebDriverError {
    new(opt_error: string): StaleElementReferenceError;
}

/**
 * An operation did not complete before its timeout expired.
 */
export class TimeoutError extends WebDriverError {
    new(opt_error: string): TimeoutError;
}

/**
 * A screen capture operation was not possible.
 */
export class UnableToCaptureScreenError extends WebDriverError {
    new(opt_error: string): UnableToCaptureScreenError;
}
/**
 * A request to set a cookies value could not be satisfied.
 */
export class UnableToSetCookieError extends WebDriverError {
    new(opt_error: string): UnableToSetCookieError;
}

/**
 * A modal dialog was open, blocking this operation.
 */
export class UnexpectedAlertOpenError extends WebDriverError {
    new(opt_error: string): UnexpectedAlertOpenError;
}

/**
 * A command could not be executed because the remote end is not aware of it.
 */
export class UnknownCommandError extends WebDriverError {
    new(opt_error: string): UnknownCommandError;
}

/**
 * The requested command matched a known URL but did not match an method for that URL.
 */
export class UnknownMethodError extends WebDriverError {
    new(opt_error: string): UnknownMethodError;
}

/**
 * Reports an unsupport operation.
 */
export class UnsupportedOperationError extends WebDriverError {
    new(opt_error: string): UnsupportedOperationError;
}

/**
 * The base WebDriver error type. This error type is only used directly when a more appropriate category is not defined for the offending error.
 */
export class WebDriverError extends Error {
    new(opt_error: string): WebDriverError;
}

export enum ErrorCode {
    SUCCESS = 0,
    NO_SUCH_ELEMENT = 7,
    NO_SUCH_FRAME = 8,
    UNKNOWN_COMMAND = 9,
    UNSUPPORTED_OPERATION = 9,
    STALE_ELEMENT_REFERENCE = 10,
    ELEMENT_NOT_VISIBLE = 11,
    INVALID_ELEMENT_STATE = 12,
    UNKNOWN_ERROR = 13,
    ELEMENT_NOT_SELECTABLE = 15,
    JAVASCRIPT_ERROR = 17,
    XPATH_LOOKUP_ERROR = 19,
    TIMEOUT = 21,
    NO_SUCH_WINDOW = 23,
    INVALID_COOKIE_DOMAIN = 24,
    UNABLE_TO_SET_COOKIE = 25,
    UNEXPECTED_ALERT_OPEN = 26,
    NO_SUCH_ALERT = 27,
    SCRIPT_TIMEOUT = 28,
    INVALID_ELEMENT_COORDINATES = 29,
    IME_NOT_AVAILABLE = 30,
    IME_ENGINE_ACTIVATION_FAILED = 31,
    INVALID_SELECTOR_ERROR = 32,
    SESSION_NOT_CREATED = 33,
    MOVE_TARGET_OUT_OF_BOUNDS = 34,
    SQL_DATABASE_ERROR = 35,
    INVALID_XPATH_SELECTOR = 51,
    INVALID_XPATH_SELECTOR_RETURN_TYPE = 52,
    METHOD_NOT_ALLOWED = 405
}

export function encodeError(err: any): { error: string, message: string };

export function checkResponse(data: any): any;

export function throwDecodedError(data: any): void;

export function checkLegacyResponse(responseObj: any): any;
}
declare module 'selenium-webdriver/lib/error' {
export * from '~selenium-webdriver/lib/error';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/promise.d.ts
declare module '~selenium-webdriver/lib/promise' {
import {EventEmitter, Listener} from '~selenium-webdriver/lib/events';

export class CancellationError extends Error {

    /**
     * @param {string=} opt_msg The cancellation message.
     */
    constructor(opt_msg: string);
}

export interface Thenable<T> {
    cancel(opt_reason: string | Error): void;

    catch<R>(errback: Function): Promise<R>;

    finally<R>(callback: Function): Promise<R>;

    isPending(): boolean;

    then<R>(opt_callback: Function, opt_errback: Function): Promise<R>;
}

export class Promise<T> implements Thenable<T> {
    constructor(resolver: Function, opt_flow?: ControlFlow);

    cancel(opt_reason?: string | Error): void;

    catch<R>(errback: Function): Promise<R>;

    finally<R>(callback: Function): Promise<R>;

    isPending(): boolean;

    then<R>(opt_callback?: Function, opt_errback?: Function): Promise<R>;
}

export class ControlFlow implements EventEmitter {

    addListener(type: string, fn: Function, opt_self?: Object): ControlFlow;

    async(fn: Function, opt_self?: Object, ...var_args: Object[]): void;

    emit(type: string, ...args: any[]): void;

    execute<T>(fn: Function, opt_description: string): Promise<T>;

    getSchedule(opt_includeStackTraces: string): string;

    isIdle(): boolean;

    listeners(type: string): Listener[];

    once(type: string, fn: Function, opt_self?: Object): ControlFlow;

    on(type: string, fn: Function, opt_self?: Object): ControlFlow;

    removeListener(type: string, listenerFn: Function): ControlFlow;

    removeAllListeners(opt_type: any): ControlFlow;

    reset(): void;

    setPropagateUnhandledRejections(propagate: boolean): void;

    timeout<T>(ms: number, opt_description: string): Promise<T>;

    wait<T>(condition: Promise<T> | Function, opt_timeout: number, opt_message: string): Promise<T>;
}

export class Deferred<T> {

    promise: Promise<T>;

    constructor(opt_flow: ControlFlow);

    fulfill(opt_value: T | Thenable<T>): void;

    reject(opt_reason: any): void;
}

export class MultipleUnhandledRejectionError extends Error {

    errors: Set<any>;

    constructor(errors: Set<any>);
}

// TODO: find out how decalre EventType in context of ControlFlow
export type EventType = {

    /** Emitted when all tasks have been successfully executed. */
    IDLE: 'idle',

    /** Emitted when a ControlFlow has been reset. */
    RESET: 'reset',

    /** Emitted whenever a new task has been scheduled. */
    SCHEDULE_TASK: 'scheduleTask',

    /**
     * Emitted whenever a control flow aborts due to an unhandled promise
     * rejection. This event will be emitted along with the offending rejection
     * reason. Upon emitting this event, the control flow will empty its task
     * queue and revert to its initial state.
     */
    UNCAUGHT_EXCEPTION: 'uncaughtException'
}

/**
 * Given an array of promises, will return a promise that will be fulfilled with the fulfillment values of the input array's values. If any of the
 * input array's promises are rejected, the returned promise will be rejected with the same reason.
 */
export function all<T>(arg: Promise<T>[]): Promise<T>;

/**
 * Invokes the appropriate callback function as soon as a promised `value` is resolved. This function is similar to `when()`, except it does not return
 * a new promise.
 */
export function asap(value: any, callback?: Function, opt_errback?: Function): void;

/**
 * Generates an error to capture the current stack trace.
 */
export function captureStackTrace(name: string, msg: string, opt_topFn?: Function): Error;

/**
 * Wraps a function that expects a node-style callback as its final argument. This callback expects two arguments: an error value (which will be
 * null if the call succeeded), and the success value as the second argument. The callback will the resolve or reject the returned promise, based on its
 * arguments.
 */
export function checkedNodeCall<T>(fn: Function, ...var_args: any[]): Promise<T>;

/**
 * Consumes a {@code GeneratorFunction}. Each time the generator yields a promise, this function will wait for it to be fulfilled before feeding the
 * fulfilled value back into {@code next}. Likewise, if a yielded promise is rejected, the rejection error will be passed to {@code throw}.
 */
export function consume<T>(generatorFn: Function, opt_self?: Object, ...var_args: any[]): Promise<T>;

/**
 * Returns The currently active control flow.
 */
export function controlFlow(): ControlFlow;

/**
 * Creates a new control flow. The provided callback will be invoked as the first task within the new flow, with the flow as its sole argument. Returns
 * a promise that resolves to the callback result.
 */
export function createFlow<T>(callback: Function): Promise<T>;

/**
 * Creates a new deferred object.
 */
export function defer<T>(): Deferred<T>;

/**
 * Creates a promise that will be resolved at a set time in the future.
 */
export function delayed<T>(ms: number): Promise<T>;

/**
 * Calls a function for each element in an array, and if the function returns true adds the element to a new array.
 *
 * If the return value of the filter function is a promise, this function will wait for it to be fulfilled before determining whether to insert the
 * element into the new array.
 *
 * If the filter function throws or returns a rejected promise, the promise returned by this function will be rejected with the same reason. Only the
 * first failure will be reported; all subsequent errors will be silently ignored.
 */
export function filter<T, S>(arr: T[] | Promise<T>, fn: Function, opt_self: S): Promise<S>;

/**
 * Creates a promise that has been resolved with the given value.
 */
export function fulfilled<T>(opt_value: T): Promise<T>;

/**
 * Returns a promise that will be resolved with the input value in a fully-resolved state. If the value is an array, each element will be fully
 * resolved. Likewise, if the value is an object, all keys will be fully resolved. In both cases, all nested arrays and objects will also be
 * fully resolved.  All fields are resolved in place; the returned promise will resolve on {@code value} and not a copy.
 */
export function fullyResolved(value: any): Promise<any>;

/**
 * Tests is a function is a generator.
 */
export function isGenerator(fn: Function): boolean;

/**
 * Determines whether a {@code value} should be treated as a promise. Any object whose "then" property is a function will be considered a promise.
 */
export function isPromise(value: any): boolean;

/**
 *  Calls a function for each element in an array and inserts the result into a new array, which is used as the fulfillment value of the promise returned
 * by this function.
 *
 * If the return value of the mapping function is a promise, this function will wait for it to be fulfilled before inserting it into the new array.
 *
 * If the mapping function throws or returns a rejected promise, the promise returned by this function will be rejected with the same reason.
 * Only the first failure will be reported; all subsequent errors will be silently ignored.
 */
export function map<T, S>(arr: T[] | Promise<T>, fn: Function, opt_self: S): void;

/**
 * Creates a promise that has been rejected with the given reason.
 */
export function rejected<T>(opt_reason: any): Promise<T>;

/**
 * Changes the default flow to use when no others are active.
 */
export function setDefaultFlow(flow: ControlFlow): void;

/**
 * Registers an observer on a promised {@code value}, returning a new promise that will be resolved when the value is. If {@code value} is not a promise,
 * then the return promise will be immediately resolved.
 */
export function when<T>(value: any, opt_callback?: Function, opt_errback?: Function): Promise<T>;
}
declare module 'selenium-webdriver/lib/promise' {
export * from '~selenium-webdriver/lib/promise';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/logging.d.ts
declare module '~selenium-webdriver/lib/logging' {
/**
 * Defines a message level that may be used to control logging output.
 */
export class Level {

    /**
     * Indicates all log messages should be recorded.
     */
    static ALL: Level;

    /**
     * Log messages with a level of `700` or higher.
     */
    static DEBUG: Level;

    /**
     * Log messages with a level of `500` or higher.
     */
    static FINE: Level;

    /**
     * Log messages with a level of `400` or higher.
     */
    static FINER: Level;

    /**
     * Log messages with a level of `300` or higher.
     */
    static FINEST: Level;

    /**
     * Log messages with a level of `800` or higher.
     */
    static INFO: Level;

    /**
     * Indicates no log messages should be recorded.
     */
    static OFF: Level;

    /**
     * Log messages with a level of `1000` or higher.
     */
    static SEVERE: Level;

    /**
     * Log messages with a level of `900` or higher.
     */
    static WARNING: Level;

    /**
     * @param {string} name the level's name.
     * @param {number} level the level's numeric value.
     */
    constructor(name: string, level: number);

    /** This logger's name. */
    name(): string;

    /** The numeric log level. */
    value(): number;
}

/**
 * Describes a single log entry.
 */
export class Entry {

    /**
     * @param {(!Level|string|number)} level The entry level.
     * @param {string} message The log message.
     * @param {number=} opt_timestamp The time this entry was generated, in
     *     milliseconds since 0:00:00, January 1, 1970 UTC. If omitted, the
     *     current time will be used.
     * @param {string=} opt_type The log type, if known.
     */
    constructor(level: Level | string | number, message: string, opt_timestamp: number, opt_type: string);

    /**
     * @return {{level: string, message: string, timestamp: number,
     *           type: string}} The JSON representation of this entry.
     */
    toJSON(): Object;
}

export class Logger {

    /**
     * @param {string} name the name of this logger.
     * @param {Level=} opt_level the initial level for this logger.
     */
    constructor (name: string, opt_level: Level);

    /** 
     * @return {string} the name of this logger.
     */
    getName(): string;

    /**
     * @param {Level} level the new level for this logger, or `null` if the logger
     *     should inherit its level from its parent logger.
     */
    setLevel(level: Level): void;

    /** 
     * @return {Level} the log level for this logger. 
     */
    getLevel(): Level;

    /**
     * @return {!Level} the effective level for this logger.
     */
    getEffectiveLevel(): Level;

    /**
     * @param {!Level} level the level to check.
     * @return {boolean} whether messages recorded at the given level are loggable
     *     by this instance.
     */
    isLoggable(level: Level): boolean;

    /**
     * Adds a handler to this logger. The handler will be invoked for each message
     * logged with this instance, or any of its descendants.
     *
     * @param {function(!Entry)} handler the handler to add.
     */
    addHandler(handler: Function): void;

    /**
     * Removes a handler from this logger.
     *
     * @param {function(!Entry)} handler the handler to remove.
     * @return {boolean} whether a handler was successfully removed.
     */
    removeHandler(handler: Function): void;

    /**
     * Logs a message at the given level. The message may be defined as a string
     * or as a function that will return the message. If a function is provided,
     * it will only be invoked if this logger's
     * {@linkplain #getEffectiveLevel() effective log level} includes the given
     * `level`.
     *
     * @param {!Level} level the level at which to log the message.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    log(level: Level, loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.SEVERE} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    severe(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.WARNING} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    warning(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.INFO} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    info(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.DEBUG} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    debug(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.FINE} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    fine(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.FINER} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    finer(loggable: string | Function): void;

    /**
     * Logs a message at the {@link Level.FINEST} log level.
     * @param {(string|function(): string)} loggable the message to log, or a
     *     function that will return the message.
     */
    finest(loggable: string | Function): void;
}

export class LogManager {

    constructor();

    /**
     * Retrieves a named logger, creating it in the process. This function will
     * implicitly create the requested logger, and any of its parents, if they
     * do not yet exist.
     *
     * @param {string} name the logger's name.
     * @return {!Logger} the requested logger.
     */
    getLogger(name: string): Logger;

    /**
     * Creates a new logger.
     *
     * @param {string} name the logger's name.
     * @param {!Logger} parent the logger's parent.
     * @return {!Logger} the new logger.
     * @private
     */
    createLogger_(name: string, parent: Logger): Logger;
}

export enum Type {
    /**
     * Logs originating from the browser.
     */
    BROWSER,

    /**
     * Logs from a WebDriver client.
     */
    CLIENT,

    /**
     * Logs from a WebDriver implementation.
     */
    DRIVER,

    /**
     * Logs related to performance.
     */
    PERFORMANCE,

    /**
     * Logs from the remote server.
     */
    SERVER
}

/**
 * Describes the log preferences for a WebDriver session.
 */
export class Preferences {
    constructor();

    /**
     * Sets the desired logging level for a particular log type.
     * @param {(string|Type)} type The log type.
     * @param {(!Level|string|number)} level The desired log level.
     * @throws {TypeError} if `type` is not a `string`.
     */
    setLevel(type: string | Type, level: Level | string | number): void;

    /**
     * Converts this instance to its JSON representation.
     * @return {Map<string, string>} The JSON representation of this set of
     *     preferences.
     */
    toJSON(): Map<string, string>;
}

/**
 * Adds the console handler to the given logger. The console handler will log
 * all messages using the JavaScript Console API.
 *
 * @param {Logger=} opt_logger The logger to add the handler to; defaults
 *     to the root logger.
 */
export function addConsoleHandler(opt_logger: Logger): void;

/**
 * Removes the console log handler from the given logger.
 *
 * @param {Logger=} opt_logger The logger to remove the handler from; defaults
 *     to the root logger.
 * @see exports.addConsoleHandler
 */
export function removeConsoleHandler(opt_logger: Logger): void;

/**
 * Installs the console log handler on the root logger.
 */
export function installConsoleHandler(): void;

/**
 * Converts a level name or value to a {@link Level} value. If the name/value
 * is not recognized, {@link Level.ALL} will be returned.
 *
 * @param {(number|string)} nameOrValue The log level name, or value, to
 *     convert.
 * @return {!Level} The converted level.
 */
export function getLevel(nameOrValue: string | number): Level;

/**
 * Retrieves a named logger, creating it in the process. This function will
 * implicitly create the requested logger, and any of its parents, if they
 * do not yet exist.
 *
 * The log level will be unspecified for newly created loggers. Use
 * {@link Logger#setLevel(level)} to explicitly set a level.
 *
 * @param {string} name the logger's name.
 * @return {!Logger} the requested logger.
 */
export function getLogger(name: string): Logger;
}
declare module 'selenium-webdriver/lib/logging' {
export * from '~selenium-webdriver/lib/logging';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/lib/until.d.ts
declare module '~selenium-webdriver/lib/until' {
import {Condition, WebElement, WebElementCondition, Alert} from '~selenium-webdriver/lib/webdriver';
import {By} from '~selenium-webdriver/lib/by';

/**
 * Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as
 *
 * 1. a numeric index into
 *     [window.frames](https://developer.mozilla.org/en-US/docs/Web/API/Window.frames)
 *     for the currently selected frame.
 * 2. a {@link ./webdriver.WebElement}, which must reference a FRAME or IFRAME
 *     element on the current page.
 * 3. a locator which may be used to first locate a FRAME or IFRAME on the
 *     current page before attempting to switch to it.
 *
 * Upon successful resolution of this condition, the driver will be left focused on the new frame.
 */
export function ableToSwitchToFrame(frame: number | WebElement | By | Function): Condition<boolean>;

export function alertIsPresent(): Condition<Alert>;

export function elementIsDisabled(element: WebElement): WebElementCondition;

export function elementIsEnabled(element: WebElement): WebElementCondition;

export function elementIsNotSelected(element: WebElement): WebElementCondition;

export function elementIsNotVisible(element: WebElement): WebElementCondition;

export function elementIsSelected(element: WebElement): WebElementCondition;

export function elementIsVisible(element: WebElement): WebElementCondition;

export function elementLocated(locator: By | Function): WebElementCondition;

export function elementTextContains(element: WebElement, substr: string): WebElementCondition;

export function elementTextIs(element: WebElement, text: string): WebElementCondition;

export function elementTextMatches(element: WebElement, regex: RegExp): WebElementCondition;

export function elementsLocated(locator: By | Function): WebElementCondition;

export function stalenessOf(element: WebElement): Condition<boolean>;

export function titleContains(substr: string): Condition<boolean>;

export function titleIs(title: string): Condition<boolean>;

export function titleMatches(regex: RegExp): Condition<boolean>;

export function urlContains(substrUrl: string): Condition<boolean>;

export function urlIs(url: string): Condition<boolean>;

export function urlMatches(regex: RegExp): Condition<boolean>;
}
declare module 'selenium-webdriver/lib/until' {
export * from '~selenium-webdriver/lib/until';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/sfali23/typings-selenium-webdriver/bcda29f4ba316f5aa444b35e314c1ab46d1f82b8/index.d.ts
declare module '~selenium-webdriver/index' {
import {EventEmitter as _EventEmitter} from '~selenium-webdriver/lib/events';
import {WebDriver as _WebDriver, WebElement as _WebElement, WebElementPromise as _WebElementPromise} from '~selenium-webdriver/lib/webdriver';
import {FileDetector as _FileDetector, Button, Key} from '~selenium-webdriver/lib/input';
import {By as _By} from '~selenium-webdriver/lib/by';
import {Capabilities as _Capabilities, Browser, Capability} from '~selenium-webdriver/lib/capabilities';
import {Session as _Session} from '~selenium-webdriver/lib/session';
import {ActionSequence as _ActionSequence} from '~selenium-webdriver/lib/actions';
import {Builder as _Builder} from '~selenium-webdriver/builder';
import * as error from '~selenium-webdriver/lib/error';
import * as promise from '~selenium-webdriver/lib/promise';
import * as logging from '~selenium-webdriver/lib/logging';
import * as until from '~selenium-webdriver/lib/until';

export {error};
export {promise};
export {logging};
export {until};

export class ActionSequence extends _ActionSequence { }

export class By extends _By {}

export class Capabilities extends _Capabilities { }

export interface EventEmitter extends _EventEmitter { }

export class FileDetector extends _FileDetector { }

export interface Session extends _Session { }

export class WebDriver extends _WebDriver { }

export class WebElement extends _WebElement { }

export class WebElementPromise extends _WebElementPromise { }

export class Builder extends _Builder { }

export {Button};
export {Browser};
export {Capability};
export {Key};
}
declare module 'selenium-webdriver/index' {
export * from '~selenium-webdriver/index';
}
declare module 'selenium-webdriver' {
export * from '~selenium-webdriver/index';
}
